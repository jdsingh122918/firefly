import { prisma } from "@/lib/db/prisma";
import {
  // Conversation, // TODO: Add to types when conversation model is implemented
  // ConversationParticipant, // TODO: Add to types when conversation model is implemented
  // CreateConversationInput, // TODO: Add to types when conversation model is implemented
  // ConversationSearchOptions, // TODO: Add to types when conversation model is implemented
  PaginatedResult,
  // MessageType, // TODO: Add to types when conversation model is implemented
} from "@/lib/types";

export class ConversationRepository {
  /**
   * Create a new conversation
   */
  async createConversation(
    data: CreateConversationInput,
  ): Promise<Conversation> {
    const conversation = await prisma.conversation.create({
      data: {
        title: data.title || null,
        type: data.type,
        familyId: data.familyId || null,
        createdBy: data.createdBy,
        participants: {
          create: data.participantIds.map((userId) => ({
            userId,
            canWrite: true,
            canManage: userId === data.createdBy, // Creator can manage
          })),
        },
      },
      include: {
        family: {
          select: {
            id: true,
            name: true,
            description: true,
          },
        },
        participants: {
          include: {
            user: {
              select: {
                id: true,
                email: true,
                firstName: true,
                lastName: true,
                role: true,
                familyRole: true,
              },
            },
          },
        },
        messages: {
          take: 1,
          orderBy: { createdAt: "desc" },
          include: {
            sender: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
    });

    return conversation as Conversation;
  }

  /**
   * Get conversation by ID with full details
   */
  async getConversationById(id: string): Promise<Conversation | null> {
    const conversation = await prisma.conversation.findUnique({
      where: { id },
      include: {
        family: {
          select: {
            id: true,
            name: true,
            description: true,
          },
        },
        participants: {
          include: {
            user: {
              select: {
                id: true,
                email: true,
                firstName: true,
                lastName: true,
                role: true,
                familyRole: true,
              },
            },
          },
        },
        messages: {
          orderBy: { createdAt: "desc" },
          take: 20, // Latest 20 messages
          include: {
            sender: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
            replyTo: {
              select: {
                id: true,
                content: true,
                sender: {
                  select: {
                    id: true,
                    firstName: true,
                    lastName: true,
                  },
                },
              },
            },
          },
        },
      },
    });

    return conversation as Conversation | null;
  }

  /**
   * Get conversations for a specific user
   */
  async getConversationsForUser(
    userId: string,
    options: ConversationSearchOptions = {},
  ): Promise<PaginatedResult<Conversation>> {
    const { type, familyId, isActive = true, page = 1, limit = 20 } = options;

    // Build where clause
    const where: {
      isActive: boolean;
      participants: {
        some: {
          userId: string;
          leftAt: null;
        };
      };
      type?: MessageType;
      familyId?: string;
    } = {
      isActive,
      participants: {
        some: {
          userId,
          leftAt: null, // User hasn't left the conversation
        },
      },
    };

    if (type) where.type = type;
    if (familyId) where.familyId = familyId;

    // Get total count
    const total = await prisma.conversation.count({ where });

    // Get conversations
    const conversations = await prisma.conversation.findMany({
      where,
      include: {
        family: {
          select: {
            id: true,
            name: true,
          },
        },
        participants: {
          include: {
            user: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
          },
        },
        messages: {
          take: 1,
          orderBy: { createdAt: "desc" },
          include: {
            sender: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
              },
            },
          },
        },
      },
      orderBy: [
        { updatedAt: "desc" }, // Most recently updated first
      ],
      skip: (page - 1) * limit,
      take: limit,
    });

    return {
      items: conversations as Conversation[],
      total,
      page,
      limit,
      hasNextPage: page * limit < total,
      hasPrevPage: page > 1,
    };
  }

  /**
   * Add participant to conversation
   */
  async addParticipant(
    conversationId: string,
    userId: string,
    permissions: { canWrite?: boolean; canManage?: boolean } = {},
  ): Promise<ConversationParticipant> {
    const participant = await prisma.conversationParticipant.create({
      data: {
        conversationId,
        userId,
        canWrite: permissions.canWrite ?? true,
        canManage: permissions.canManage ?? false,
      },
      include: {
        user: {
          select: {
            id: true,
            email: true,
            firstName: true,
            lastName: true,
            role: true,
          },
        },
        conversation: {
          select: {
            id: true,
            title: true,
            type: true,
          },
        },
      },
    });

    return participant as ConversationParticipant;
  }

  /**
   * Remove participant from conversation
   */
  async removeParticipant(
    conversationId: string,
    userId: string,
  ): Promise<void> {
    await prisma.conversationParticipant.updateMany({
      where: {
        conversationId,
        userId,
      },
      data: {
        leftAt: new Date(),
      },
    });
  }

  /**
   * Update conversation details
   */
  async updateConversation(
    id: string,
    data: { title?: string; isActive?: boolean },
  ): Promise<Conversation> {
    const conversation = await prisma.conversation.update({
      where: { id },
      data,
      include: {
        family: {
          select: {
            id: true,
            name: true,
            description: true,
          },
        },
        participants: {
          where: { leftAt: null }, // Only active participants
          include: {
            user: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                role: true,
              },
            },
          },
        },
      },
    });

    return conversation as Conversation;
  }

  /**
   * Check if user is participant in conversation
   */
  async isUserParticipant(
    conversationId: string,
    userId: string,
  ): Promise<boolean> {
    const participant = await prisma.conversationParticipant.findFirst({
      where: {
        conversationId,
        userId,
        leftAt: null,
      },
    });

    return !!participant;
  }

  /**
   * Get user's permissions in conversation
   */
  async getUserPermissions(
    conversationId: string,
    userId: string,
  ): Promise<{ canWrite: boolean; canManage: boolean } | null> {
    const participant = await prisma.conversationParticipant.findFirst({
      where: {
        conversationId,
        userId,
        leftAt: null,
      },
      select: {
        canWrite: true,
        canManage: true,
      },
    });

    return participant;
  }

  /**
   * Create direct conversation between two users
   */
  async createDirectConversation(
    user1Id: string,
    user2Id: string,
  ): Promise<Conversation> {
    // Check if direct conversation already exists
    const existingConversation = await prisma.conversation.findFirst({
      where: {
        type: MessageType.DIRECT,
        participants: {
          every: {
            userId: { in: [user1Id, user2Id] },
            leftAt: null,
          },
        },
      },
      include: {
        participants: true,
      },
    });

    // If exists and has exactly 2 participants, return it
    if (
      existingConversation &&
      existingConversation.participants?.length === 2
    ) {
      return this.getConversationById(
        existingConversation.id,
      ) as Promise<Conversation>;
    }

    // Create new direct conversation
    return this.createConversation({
      type: MessageType.DIRECT,
      createdBy: user1Id,
      participantIds: [user1Id, user2Id],
    });
  }

  /**
   * Create family chat conversation
   */
  async createFamilyChat(
    familyId: string,
    createdBy: string,
    title?: string,
  ): Promise<Conversation> {
    // Get all family members
    const family = await prisma.family.findUnique({
      where: { id: familyId },
      include: {
        members: {
          select: { id: true },
        },
      },
    });

    if (!family) {
      throw new Error("Family not found");
    }

    const participantIds = family.members.map((member) => member.id);

    return this.createConversation({
      title: title || `${family.name} Family Chat`,
      type: MessageType.FAMILY_CHAT,
      familyId,
      createdBy,
      participantIds,
    });
  }

  /**
   * Delete conversation (soft delete)
   */
  async deleteConversation(id: string): Promise<void> {
    await prisma.conversation.update({
      where: { id },
      data: { isActive: false },
    });
  }
}
